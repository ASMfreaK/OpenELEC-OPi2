diff -Nur a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp	2016-02-22 21:23:27.000000000 +0100
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp	2016-03-17 23:27:12.189483934 +0100
@@ -100,6 +100,9 @@
 {
   m_context = 0;
   m_refCount = 0;
+  m_vdpFlipTarget = VDP_INVALID_HANDLE;
+  m_vdpFlipQueue = VDP_INVALID_HANDLE;
+  m_vdpDevice = VDP_INVALID_HANDLE;
 }
 
 void CVDPAUContext::Release()
@@ -199,17 +202,24 @@
 {
   CLog::Log(LOGNOTICE,"VDPAU::CreateContext - creating decoder context");
 
+#if HAS_X11
   int mScreen;
   { CSingleLock lock(g_graphicsContext);
     if (!m_display)
       m_display = XOpenDisplay(NULL);
     mScreen = g_Windowing.GetCurrentScreen();
   }
+#endif
 
   VdpStatus vdp_st;
   // Create Device
-  vdp_st = dl_vdp_device_create_x11(m_display,
+  vdp_st = dl_vdp_device_create_x11(
+#if HAS_X11
+                                    m_display,
                                     mScreen,
+#else
+                                    0, 0,
+#endif
                                    &m_vdpDevice,
                                    &m_vdpProcs.vdp_get_proc_address);
 
@@ -223,6 +233,20 @@
 
   QueryProcs();
   SpewHardwareAvailable();
+  
+#ifndef HAS_GL
+  vdp_st = m_vdpProcs.vdp_presentation_queue_target_create_x11(m_vdpDevice, 0,
+        &m_vdpFlipTarget);
+  if (CheckStatus(vdp_st, __LINE__))
+     return false;
+  
+  vdp_st = m_vdpProcs.vdp_presentation_queue_create(m_vdpDevice,
+        m_vdpFlipTarget,
+        &m_vdpFlipQueue);
+  if (CheckStatus(vdp_st, __LINE__))
+     return false;
+#endif
+
   return true;
 }
 
@@ -264,6 +288,14 @@
   VDP_PROC(VDP_FUNC_ID_DECODER_DESTROY                     , m_vdpProcs.vdp_decoder_destroy);
   VDP_PROC(VDP_FUNC_ID_DECODER_RENDER                      , m_vdpProcs.vdp_decoder_render);
   VDP_PROC(VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES          , m_vdpProcs.vdp_decoder_query_caps);
+  VDP_PROC(VDP_FUNC_ID_PRESENTATION_QUEUE_CREATE           , m_vdpProcs.vdp_presentation_queue_create);
+  VDP_PROC(VDP_FUNC_ID_PRESENTATION_QUEUE_DESTROY          , m_vdpProcs.vdp_presentation_queue_destroy);
+  VDP_PROC(VDP_FUNC_ID_PRESENTATION_QUEUE_DISPLAY          , m_vdpProcs.vdp_presentation_queue_display);
+  VDP_PROC(VDP_FUNC_ID_PRESENTATION_QUEUE_BLOCK_UNTIL_SURFACE_IDLE, m_vdpProcs.vdp_presentation_queue_block_until_surface_idle);
+  VDP_PROC(VDP_FUNC_ID_PRESENTATION_QUEUE_TARGET_CREATE_X11, m_vdpProcs.vdp_presentation_queue_target_create_x11);
+  VDP_PROC(VDP_FUNC_ID_PRESENTATION_QUEUE_QUERY_SURFACE_STATUS, m_vdpProcs.vdp_presentation_queue_query_surface_status);
+  VDP_PROC(VDP_FUNC_ID_PRESENTATION_QUEUE_GET_TIME         , m_vdpProcs.vdp_presentation_queue_get_time);
+  VDP_PROC(VDP_FUNC_ID_PRESENTATION_QUEUE_TARGET_DESTROY   , m_vdpProcs.vdp_presentation_queue_target_destroy);
 #undef VDP_PROC
 }
 
@@ -272,13 +304,37 @@
   return m_vdpDevice;
 }
 
+bool CVDPAUContext::CheckStatus(VdpStatus vdp_st, int line)
+{
+  if (vdp_st != VDP_STATUS_OK)
+  {
+    CLog::Log(LOGERROR, " (VDPAU) Error: %s(%d) at %s:%d\n", m_vdpProcs.vdp_get_error_string(vdp_st), vdp_st, __FILE__, line);
+    return true;
+  }
+  return false;
+}
+
 void CVDPAUContext::DestroyContext()
 {
-  if (!m_vdpProcs.vdp_device_destroy)
-    return;
+  VdpStatus vdp_st;
+  
+  if (m_vdpDevice != VDP_INVALID_HANDLE)
+  {
+     m_vdpProcs.vdp_device_destroy(m_vdpDevice);
+     m_vdpDevice = VDP_INVALID_HANDLE;
+  }
+  
+  if (m_vdpFlipQueue != VDP_INVALID_HANDLE)
+  {
+     vdp_st = m_vdpProcs.vdp_presentation_queue_destroy(m_vdpFlipQueue);
+     m_vdpFlipQueue = VDP_INVALID_HANDLE;
+  }
 
-  m_vdpProcs.vdp_device_destroy(m_vdpDevice);
-  m_vdpDevice = VDP_INVALID_HANDLE;
+  if (m_vdpFlipTarget != VDP_INVALID_HANDLE)
+  {
+     vdp_st = m_vdpProcs.vdp_presentation_queue_target_destroy(m_vdpFlipTarget);
+     m_vdpFlipTarget = VDP_INVALID_HANDLE;
+  }
 }
 
 void CVDPAUContext::SpewHardwareAvailable()  //CopyrighVDPAUt (c) 2008 Wladimir J. van der Laan  -- VDPInfo
@@ -498,15 +554,13 @@
       return false;
   }
 
-#ifndef GL_NV_vdpau_interop
-  CLog::Log(LOGNOTICE, "VDPAU: compilation without required extension GL_NV_vdpau_interop");
-  return false;
-#endif
+#ifdef GL_NV_vdpau_interop
   if (!g_Windowing.IsExtSupported("GL_NV_vdpau_interop"))
   {
     CLog::Log(LOGNOTICE, "VDPAU::Open: required extension GL_NV_vdpau_interop not found");
     return false;
   }
+#endif
 
   if(avctx->coded_width  == 0
   || avctx->coded_height == 0)
@@ -530,7 +584,7 @@
 
     // convert FFMPEG codec ID to VDPAU profile.
     ReadFormatOf(avctx->codec_id, profile, m_vdpauConfig.vdpChromaType);
-    if(profile)
+    if(profile != 0xffffffffUL)
     {
       VdpStatus vdp_st;
       VdpBool is_supported = false;
@@ -580,7 +634,9 @@
       mainctx->slice_flags = SLICE_FLAG_CODED_ORDER|SLICE_FLAG_ALLOW_FIELD;
       mainctx->hwaccel_context = &m_hwContext;
 
+#if HAS_GL
       g_Windowing.Register(this);
+#endif
       return true;
     }
   }
@@ -596,7 +652,9 @@
 {
   CLog::Log(LOGNOTICE, " (VDPAU) %s", __FUNCTION__);
 
+#if HAS_GL
   g_Windowing.Unregister(this);
+#endif
 
   CSingleLock lock(m_DecoderSection);
 
@@ -652,7 +710,7 @@
 
 void CDecoder::SetWidthHeight(int width, int height)
 {
-  m_vdpauConfig.upscale = g_advancedSettings.m_videoVDPAUScaling;
+  m_vdpauConfig.upscale = 0; //g_advancedSettings.m_videoVDPAUScaling;
 
   //pick the smallest dimensions, so we downscale with vdpau and upscale with opengl when appropriate
   //this requires the least amount of gpu memory bandwidth
@@ -866,8 +924,8 @@
       vdp_chroma_type     = VDP_CHROMA_TYPE_420;
       break;
     default:
-      vdp_decoder_profile = 0;
-      vdp_chroma_type     = 0;
+      vdp_decoder_profile = 0xffffffffUL;
+      vdp_chroma_type     = 0xffffffffUL;
       break;
   }
 }
@@ -1077,6 +1135,25 @@
   return 0;
 }
 
+void CDecoder::Present(uint32_t surface)
+{
+  CLog::Log(LOGNOTICE,"CDecode::%s sourceIdx=%d",__FUNCTION__, surface);
+  VdpStatus vdp_st;
+
+#if 0
+  CSingleLock lock(m_DecoderSection);
+   { CSharedLock dLock(m_DisplaySection);
+   if (m_DisplayState != VDPAU_OPEN)
+      return;
+   }
+#endif
+  vdp_st = m_vdpauConfig.context->GetProcs().vdp_presentation_queue_display(m_vdpauConfig.context->m_vdpFlipQueue,
+                                           surface,
+                                           0,
+                                           0,
+                                           0);
+  CheckStatus(vdp_st, __LINE__);
+}
 
 int CDecoder::Decode(AVCodecContext *avctx, AVFrame *pFrame)
 {
@@ -1268,8 +1345,8 @@
         m_DisplayEvent.Reset();
         m_DisplayState = VDPAU_LOST;
       }
-      else if (m_ErrorCount > 2)
-        m_DisplayState = VDPAU_ERROR;
+      //else if (m_ErrorCount > 2)
+      //  m_DisplayState = VDPAU_ERROR;
     }
 
     return true;
@@ -2522,11 +2599,25 @@
   sourceRect.y1 = m_config.vidHeight;
 
   VdpRect destRect;
-  destRect.x0 = 0;
-  destRect.y0 = 0;
+  destRect.x0 = (g_graphicsContext.GetWidth() - m_config.outWidth) / 2;
+  destRect.y0 = (g_graphicsContext.GetHeight() - m_config.outHeight) / 2;
   destRect.x1 = m_config.outWidth;
   destRect.y1 = m_config.outHeight;
 
+  if(m_videoMixer == VDP_INVALID_HANDLE)
+    CLog::Log(LOGDEBUG, " (VDPAU) : %s(%d) m_videoMixer is invalid\n", __FUNCTION__, __LINE__);
+  if(m_processPicture.outputSurface == VDP_INVALID_HANDLE)
+    CLog::Log(LOGDEBUG, " (VDPAU) : %s(%d) outputSurface is invalid\n", __FUNCTION__, __LINE__);
+  if(m_mixerInput[1].videoSurface == VDP_INVALID_HANDLE)
+    CLog::Log(LOGDEBUG, " (VDPAU) : %s(%d) video_surface_current is invalid\n", __FUNCTION__, __LINE__);
+  
+#if !GL_NV_vdpau_interop
+  VdpTime time;
+  vdp_st = m_config.context->GetProcs().vdp_presentation_queue_block_until_surface_idle(
+                                          m_config.context->m_vdpFlipQueue,
+                                     m_processPicture.outputSurface,&time);
+#endif
+
   // start vdpau video mixer
   vdp_st = m_config.context->GetProcs().vdp_video_mixer_render(m_videoMixer,
                                 VDP_INVALID_HANDLE,
@@ -3581,6 +3672,7 @@
 
 bool COutput::CreateGlxContext()
 {
+#if HAS_X11
   GLXContext   glContext;
 
   m_Display = g_Windowing.GetDisplay();
@@ -3631,6 +3723,7 @@
     CLog::Log(LOGINFO, "VDPAU::COutput::CreateGlxContext - Could not make Pixmap current");
     return false;
   }
+#endif
 
   CLog::Log(LOGNOTICE, "VDPAU::COutput::CreateGlxContext - created context");
   return true;
@@ -3638,6 +3731,7 @@
 
 bool COutput::DestroyGlxContext()
 {
+#if HAS_X11
   if (m_glContext)
   {
     glXMakeCurrent(m_Display, None, NULL);
@@ -3652,6 +3746,7 @@
   if (m_pixmap)
     XFreePixmap(m_Display, m_pixmap);
   m_pixmap = 0;
+#endif
 
   return true;
 }
diff -Nur a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h	2016-02-22 21:23:27.000000000 +0100
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h	2016-03-01 23:17:55.420495456 +0100
@@ -42,10 +42,12 @@
 
 #include "DVDVideoCodec.h"
 #include "DVDVideoCodecFFmpeg.h"
+#ifdef HAVE_X11
 #include <X11/Xlib.h>
 #include <X11/Xutil.h>
 #define GLX_GLXEXT_PROTOTYPES
 #include <GL/glx.h>
+#endif
 
 #include "DVDVideoCodec.h"
 #include "DVDVideoCodecFFmpeg.h"
@@ -67,6 +69,11 @@
 #define FULLHD_WIDTH                       1920
 #define MAX_PIC_Q_LENGTH                   20 //for non-interop_yuv this controls the max length of the decoded pic to render completion Q
 
+#ifndef HAVE_X11
+typedef void *Display;
+typedef void *Window;
+#endif
+
 namespace VDPAU
 {
 
@@ -110,6 +117,15 @@
   VdpDecoderQueryCapabilities *  vdp_decoder_query_caps;
 
   VdpPreemptionCallbackRegister * vdp_preemption_callback_register;
+  
+  VdpPresentationQueueTargetDestroy *           vdp_presentation_queue_target_destroy;
+  VdpPresentationQueueCreate *                  vdp_presentation_queue_create;
+  VdpPresentationQueueDestroy *                 vdp_presentation_queue_destroy;
+  VdpPresentationQueueDisplay *                 vdp_presentation_queue_display;
+  VdpPresentationQueueBlockUntilSurfaceIdle *   vdp_presentation_queue_block_until_surface_idle;
+  VdpPresentationQueueTargetCreateX11 *         vdp_presentation_queue_target_create_x11;
+  VdpPresentationQueueQuerySurfaceStatus *      vdp_presentation_queue_query_surface_status;
+  VdpPresentationQueueGetTime *                 vdp_presentation_queue_get_time;
 
 };
 
@@ -214,7 +230,11 @@
   friend class COutput;
 public:
   CVdpauRenderPicture(CCriticalSection &section)
-    : refCount(0), renderPicSection(section) { fence = None; }
+    : refCount(0), renderPicSection(section) {
+#if HAS_GL
+      fence = None; 
+#endif      
+    }
   void Sync();
   DVDVideoPicture DVDPic;
   int texWidth, texHeight;
@@ -228,7 +248,9 @@
 private:
   void ReturnUnused();
   bool usefence;
+#if HAS_GL
   GLsync fence;
+#endif
   int refCount;
   CCriticalSection &renderPicSection;
 };
@@ -459,10 +481,12 @@
   CMixer m_mixer;
   Display *m_Display;
   Window m_Window;
+#if HAS_GL
   GLXContext m_glContext;
   GLXWindow m_glWindow;
   Pixmap    m_pixmap;
   GLXPixmap m_glPixmap;
+#endif
 
   // gl functions
 #ifdef GL_NV_vdpau_interop
@@ -515,6 +539,9 @@
   bool Supports(VdpVideoMixerFeature feature);
   VdpVideoMixerFeature* GetFeatures();
   int GetFeatureCount();
+  
+  VdpPresentationQueueTarget   m_vdpFlipTarget;
+  VdpPresentationQueue         m_vdpFlipQueue;
 private:
   CVDPAUContext();
   void Close();
@@ -523,6 +550,7 @@
   void DestroyContext();
   void QueryProcs();
   void SpewHardwareAvailable();
+  bool CheckStatus(VdpStatus vdp_st, int line);
   static CVDPAUContext *m_context;
   static CCriticalSection m_section;
   static Display *m_display;
@@ -567,6 +595,8 @@
 
   virtual int  Check(AVCodecContext* avctx);
   virtual const std::string Name() { return "vdpau"; }
+  
+  void Present(uint32_t surface);
 
   bool Supports(VdpVideoMixerFeature feature);
   bool Supports(EINTERLACEMETHOD method);
diff -Nur a/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp b/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
--- a/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp	2016-02-22 21:23:27.000000000 +0100
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp	2016-03-17 22:00:19.546450833 +0100
@@ -116,6 +116,9 @@
 #ifdef HAS_IMXVPU
   IMXBuffer = NULL;
 #endif
+#ifdef HAVE_LIBVDPAU
+  vdpau = NULL;
+#endif
 }
 
 CLinuxRendererGLES::YUVBUFFER::~YUVBUFFER()
@@ -312,6 +315,13 @@
   }
 #endif
 
+#ifdef HAVE_LIBVDPAU
+  if(m_renderMethod & RENDER_VDPAU)
+  {
+    return source;
+  }
+#endif
+
   YV12Image &im = m_buffers[source].image;
 
   if ((im.flags&(~IMAGE_FLAG_READY)) != 0)
@@ -733,6 +743,44 @@
 #endif
   }
 #endif
+#ifdef HAVE_LIBVDPAU
+  else if (m_renderMethod & RENDER_VDPAU)
+  {
+    VDPAU::CVdpauRenderPicture *buffer = m_buffers[m_iYV12RenderBuffer].vdpau;
+    if (buffer != NULL && buffer->valid)
+    {
+      // this hack is needed to get the 2D mode of a 3D movie going
+      RENDER_STEREO_MODE stereo_mode = g_graphicsContext.GetStereoMode();
+      if (stereo_mode)
+        g_graphicsContext.SetStereoView(RENDER_STEREO_VIEW_LEFT);
+
+      ManageDisplay();
+
+      if (stereo_mode)
+        g_graphicsContext.SetStereoView(RENDER_STEREO_VIEW_OFF);
+
+      CRect dstRect(m_destRect);
+      CRect srcRect(m_sourceRect);
+      switch (stereo_mode)
+      {
+        case RENDER_STEREO_MODE_SPLIT_HORIZONTAL:
+          dstRect.y2 *= 2.0;
+          srcRect.y2 *= 2.0;
+        break;
+
+        case RENDER_STEREO_MODE_SPLIT_VERTICAL:
+          dstRect.x2 *= 2.0;
+          srcRect.x2 *= 2.0;
+        break;
+
+        default:
+        break;
+      }
+      
+      buffer->vdpau->Present(buffer->sourceIdx);
+    }
+  }
+#endif
 }
 
 void CLinuxRendererGLES::FlipPage(int source)
@@ -906,6 +954,12 @@
         m_renderMethod = RENDER_CVREF;
         break;
       }
+      else if (m_format == RENDER_FMT_VDPAU)
+      {
+        CLog::Log(LOGNOTICE, "GL: Using VDPAU render method");
+        m_renderMethod = RENDER_VDPAU;
+        break;
+      }
       #if defined(TARGET_DARWIN_IOS)
       else if (ios_version < 5.0 && m_format == RENDER_FMT_YUV420P)
       {
@@ -998,7 +1052,13 @@
     m_textureCreate = &CLinuxRendererGLES::CreateOpenMaxTexture;
     m_textureDelete = &CLinuxRendererGLES::DeleteOpenMaxTexture;
   }
-   else
+  else if (m_format == RENDER_FMT_VDPAU)
+  {
+    m_textureUpload = &CLinuxRendererGLES::UploadVDPAUTexture;
+    m_textureCreate = &CLinuxRendererGLES::CreateVDPAUTexture;
+    m_textureDelete = &CLinuxRendererGLES::DeleteVDPAUTexture;
+  }
+  else
   {
     // default to YV12 texture handlers
     m_textureUpload = &CLinuxRendererGLES::UploadYV12Texture;
@@ -1110,6 +1170,10 @@
   if (m_renderMethod & RENDER_IMXMAP)
     SAFE_RELEASE(buf.IMXBuffer);
 #endif
+#ifdef HAVE_LIBVDPAU
+  if (m_renderMethod & RENDER_VDPAU)
+    SAFE_RELEASE(buf.vdpau);
+#endif
 }
 
 void CLinuxRendererGLES::Render(DWORD flags, int index)
@@ -2890,6 +2954,30 @@
   return true;
 }
 
+//********************************************************************************************************
+// VDPAU creation, deletion, copying + clearing
+//********************************************************************************************************
+void CLinuxRendererGLES::UploadVDPAUTexture(int index)
+{
+  CLog::Log(LOGDEBUG, " (VDPAU) : %s(%d) index = %d\n", __FUNCTION__, __LINE__, index);
+}
+
+void CLinuxRendererGLES::DeleteVDPAUTexture(int index)
+{
+  CLog::Log(LOGDEBUG, " (VDPAU) : %s(%d) index = %d\n", __FUNCTION__, __LINE__, index);
+#ifdef HAVE_LIBVDPAU
+  SAFE_RELEASE(m_buffers[index].vdpau);
+#endif
+}
+
+bool CLinuxRendererGLES::CreateVDPAUTexture(int index)
+{
+  CLog::Log(LOGDEBUG, " (VDPAU) : %s(%d) index = %d\n", __FUNCTION__, __LINE__, index);
+#ifdef HAVE_LIBVDPAU
+  m_buffers[index].vdpau = 0;
+#endif
+  return true;
+}
 
 bool CLinuxRendererGLES::Supports(ERENDERFEATURE feature)
 {
@@ -3008,6 +3096,16 @@
     else
       return false;
   }
+  
+  if(m_renderMethod & RENDER_VDPAU)
+  {
+#ifdef HAVE_LIBVDPAU
+    VDPAU::CVdpauRenderPicture *vdpauPic = m_buffers[m_iYV12RenderBuffer].vdpau;
+    if(vdpauPic && vdpauPic->vdpau)
+       return vdpauPic->vdpau->Supports(method);
+#endif
+    return false;
+  }
 
 #if !defined(TARGET_ANDROID) && (defined(__i386__) || defined(__x86_64__))
   if(method == VS_INTERLACEMETHOD_DEINTERLACE
@@ -3073,6 +3171,9 @@
 
   if(m_renderMethod & RENDER_IMXMAP)
     return VS_INTERLACEMETHOD_IMX_FASTMOTION;
+  
+  if(m_renderMethod & RENDER_VDPAU)
+    return VS_INTERLACEMETHOD_NONE;
 
 #if !defined(TARGET_ANDROID) && (defined(__i386__) || defined(__x86_64__))
   return VS_INTERLACEMETHOD_DEINTERLACE_HALF;
@@ -3090,7 +3191,8 @@
      m_format == RENDER_FMT_CVBREF ||
      m_format == RENDER_FMT_EGLIMG ||
      m_format == RENDER_FMT_MEDIACODEC ||
-    m_format == RENDER_FMT_MEDIACODECSURFACE)
+     m_format == RENDER_FMT_MEDIACODECSURFACE ||
+     m_format == RENDER_FMT_VDPAU)
     info.optimal_buffer_size = 2;
   else if(m_format == RENDER_FMT_IMXMAP)
   {
@@ -3187,9 +3289,20 @@
 }
 #endif
 
+#ifdef HAVE_LIBVDPAU
+void CLinuxRendererGLES::AddProcessor(VDPAU::CVdpauRenderPicture* vdpau, int index)
+{
+  YUVBUFFER &buf = m_buffers[index];
+  VDPAU::CVdpauRenderPicture *pic = vdpau->Acquire();
+  SAFE_RELEASE(buf.vdpau);
+  buf.vdpau = pic;
+}
+#endif
+
 bool CLinuxRendererGLES::IsGuiLayer()
 {
-  if (m_format == RENDER_FMT_BYPASS || m_format == RENDER_FMT_IMXMAP || m_format == RENDER_FMT_MEDIACODECSURFACE)
+  if (m_format == RENDER_FMT_BYPASS || m_format == RENDER_FMT_IMXMAP ||
+      m_format == RENDER_FMT_MEDIACODECSURFACE || m_format == RENDER_FMT_VDPAU)
     return false;
   else
     return true;
diff -Nur a/xbmc/cores/VideoRenderers/LinuxRendererGLES.h b/xbmc/cores/VideoRenderers/LinuxRendererGLES.h
--- a/xbmc/cores/VideoRenderers/LinuxRendererGLES.h	2016-02-22 21:23:27.000000000 +0100
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGLES.h	2016-03-01 20:56:02.329770386 +0100
@@ -33,6 +33,7 @@
 #include "guilib/GraphicContext.h"
 #include "BaseRenderer.h"
 #include "xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h"
+#include "xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h"
 
 class CRenderCapture;
 
@@ -87,6 +88,7 @@
 {
   RENDER_GLSL   = 0x001,
   RENDER_SW     = 0x004,
+  RENDER_VDPAU  = 0x008,
   RENDER_POT    = 0x010,
   RENDER_OMXEGL = 0x040,
   RENDER_CVREF  = 0x080,
@@ -177,6 +179,9 @@
 #ifdef HAS_IMXVPU
   virtual void         AddProcessor(CDVDVideoCodecIMXBuffer *codecinfo, int index);
 #endif
+#ifdef HAVE_LIBVDPAU
+  virtual void         AddProcessor(VDPAU::CVdpauRenderPicture* vdpau, int index);
+#endif
 
 protected:
   virtual void Render(DWORD flags, int index);
@@ -225,6 +230,10 @@
   void UploadIMXMAPTexture(int index);
   void DeleteIMXMAPTexture(int index);
   bool CreateIMXMAPTexture(int index);
+  
+  void UploadVDPAUTexture(int index);
+  void DeleteVDPAUTexture(int index);
+  bool CreateVDPAUTexture(int index);
 
   void CalculateTextureSourceRects(int source, int num_planes);
 
@@ -306,6 +315,9 @@
 #ifdef HAS_IMXVPU
     CDVDVideoCodecIMXBuffer *IMXBuffer;
 #endif
+#ifdef HAVE_LIBVDPAU
+    VDPAU::CVdpauRenderPicture *vdpau;
+#endif
   };
 
   typedef YUVBUFFER          YUVBUFFERS[NUM_BUFFERS];
